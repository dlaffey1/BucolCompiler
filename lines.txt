COMMANDS:
flex lexer.l
bison -d parser.y
gcc lex.yy.c parser.tab.c -o parser
./parser

Nice reference for flex:
https://westes.github.io/flex/manual/Patterns.html#Patterns

PROJECT SPEC BELOW THIS LINE
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Compiler Theory: A Parser for BUCOL Programs 

Project 2024 

 

Overview 

Your task is to develop a Parser (and associated Lexical analysis tool) for a syntactically limited language.
This tool should report back to tell the programmer when the program is correctly and incorrectly formed with respect to its structure.
It only needs to analyse the program, not create an executable. 

 

You should use the tools presented to you in the Compiler Theory module for lexical and syntactical analysis. 

 

Language Syntax: 

 

The language is not case sensitive. - 
Programs are monolithic starting with the keyword “BEGINING.” and ending with the keyword "END.” (The periods are important) 

 

Statements in the program can be divided into declarations, assignments, inputs, and outputs. 

 

Declarations are contained just below the BEGINING keyword.
Only variables of type integer are supported in BUCOL.
In the individual declaration of each variable, the first string defines the capacity of the integer being declared.
This string will always be represented by one of more X’s.
For example a variable declared as XXX specifies that a three-digit number can be held in the variable.
A XXXX specifies that a five-digit number can be held in the variable. 

 

The identifier follows the size string and is the name of the variable being declared.
It will be any combination of alphabetic characters, digits, and hyphens, as long as it starts with a character and is not a series of contiguous X's.
Examples include: 

 

XXX G56-MH. 

XXXX HTY. 

XXX X-. 

XXXXX U6787-77. 

 

After the declarations, comes the main body of code, signified by the keyword "BODY.".
This body of code consists of one or more statements after this keyword.
The program ends with the "END." statement. 

 

The assignment statements are of either of the following forms: 

 

MOVE identifier TO identifier. 

MOVE integer TO identifier. 

 

Here a value (specified by the integer or identifier after the MOVE keyword) is assigned to the variable,
identified by the identifier at the end of the statement.
Alternatively, an addition statement can be of the forms: 

 

ADD integer TO identifier. 

ADD identifier TO identifier. 

 

The input statement is of the following form: 

 

INPUT identifier1; identifier2; identifier3. 

 

This read statement above will take in 3 values which will be held in the variables identified by identifier1, identifier 2 and identifier3.
However read statements are not just limited to taking in 3 values. They may take in any number of values required by the program. 

 

The output statement is of the following form: 

 

PRINT “I’m printed out”; identifier1. 

 

It starts with the keyword ‘Print’ and then contains any combinations of either identifiers or text (enclosed in quotation marks),
separated by semi-colons.
The print statement above prints out the string ‘I’m printed out’, followed by whatever value is held by identifier 1. 

 

A valid example program is in programs/valid.bucol

A invalid example program is in programs/invalid.bucol: the printed variable XY is not declared 

Deadlines and Marks: 

This project should be completed by Monday of week 7 of this block: 09:00am.
It is intended that you do this in your own time.
Abdul will be there to offer email support.    

 

A key milestone along the way is the lexical scanner.
That should identify all the tokens of the language, (maybe) showing this by printing out each token type on their recognition.
This might be a useful intermediate step for your project but is not technically required.  

 

The parser should report that it has been presented with a well formed/not well formed program.
It should also flag an error if the program attempts to assign a value to a variable that is not declared or assign a value to a variable
which is bigger than its declared capacity.
For example, using the program above, if a program tried to ‘MOVE 500000 TO Y’ a warning flag should be raised (as Y is only declared as ‘XXXX’).
For top marks the parser should detect if,
when you move a value from an identifier 1 to an identifier 2, identifier 1 is declared to be larger than identifier 2 and issue a warning.
(in the example above 'MOVE Z to XY-1' should cause this) 

 

Your Lex/and YACC files should be submitted,
along with a readme that details how to build and run your parser,
to Brightspace by Monday, week 7 of this block: 09:00am.


 

12/30 will be awarded to the lexer and 18/30 awarded to the syntax parser.
But incomplete projects/non-working projects/projects that don’t identify all errors may still be awarded marks based on source code inspection.  

 
